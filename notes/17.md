# **The Four Pillars of OOP**


### **1. Encapsulation**

- **Definition**: Encapsulation is the concept of wrapping data (attributes) and methods that operate on the data within a single unit or class. It restricts direct access to certain components, keeping internal details private and exposing only necessary parts.
- **Private Variables**: In Python, we can make attributes private by prefixing them with a double underscore `__`. Private variables are only accessible within the class and cannot be accessed directly from outside, ensuring data protection.

#### **Example**:
```python
class Account:
    def __init__(self, owner, balance):
        self.owner = owner          # Public variable
        self.__balance = balance     # Private variable

    def deposit(self, amount):
        self.__balance += amount
        print(f"Deposited: {amount}")

    def get_balance(self):
        return self.__balance

# Creating an Account object
acc = Account("Arjun", 5000)
acc.deposit(1500)
print(f"Balance: {acc.get_balance()}")  # Accessing balance through a public method
```

**Output**:
```
Deposited: 1500
Balance: 6500
```

Here:
- `__balance` is a private variable, making it inaccessible directly outside the class.
- Accessing `__balance` directly with `acc.__balance` would result in an error, enforcing data protection.

---

### **2. Abstraction**

- **Definition**: Abstraction is the process of hiding complex implementation details and exposing only the necessary parts of an object. It enables users to interact with a system or object without needing to understand its internal workings.
- **Purpose**: Simplifies interaction with complex systems by providing a clean and minimal interface.

#### **Example**:
In a car, drivers don’t need to know how the engine works; they only need to know how to start, accelerate, and stop it. Similarly, in programming, we use abstraction to expose only the essential functionalities.

```python
class Car:
    def start(self):
        print("Car started")

    def stop(self):
        print("Car stopped")

# Using the Car class without needing to know its inner workings
car = Car()
car.start()
car.stop()
```

**Output**:
```
Car started
Car stopped
```

In this example, the user doesn’t know (or need to know) how `start()` or `stop()` work internally; they simply use these methods.

---

### **3. Inheritance**

- **Definition**: Inheritance is the process by which a class (child) can acquire properties and methods of another class (parent). It enables code reuse and establishes a relationship between classes.
- **Purpose**: Allows us to create new classes that inherit the behavior and attributes of existing classes, promoting efficiency and code reuse.

#### **Example**:
```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def drive(self):
        print("Vehicle is moving")

class Car(Vehicle):  # Car inherits from Vehicle
    def __init__(self, brand, model):
        super().__init__(brand)
        self.model = model

    def honk(self):
        print("Car is honking")

# Creating an object of Car
car = Car("Toyota", "Corolla")
print(f"Brand: {car.brand}, Model: {car.model}")
car.drive()
car.honk()
```

**Output**:
```
Brand: Toyota, Model: Corolla
Vehicle is moving
Car is honking
```

Here:
- The `Car` class inherits the `drive()` method from the `Vehicle` class, showcasing code reuse.

---

### **4. Polymorphism**

- **Definition**: Polymorphism means having many forms. In programming, it allows methods to do different things based on the object they are called on, even if they share the same name.
- **Purpose**: Allows the same function or method to behave differently on different classes, increasing flexibility in code.

#### **Example**:
```python
class Bird:
    def sound(self):
        return "Chirp"

class Dog:
    def sound(self):
        return "Bark"

# Demonstrating polymorphism
for animal in (Bird(), Dog()):
    print(animal.sound())
```

**Output**:
```
Chirp
Bark
```

In this example:
- Both `Bird` and `Dog` have a `sound()` method, but calling `sound()` on each object produces different results, demonstrating polymorphism.

---

### **5. Homework**

1. **Encapsulation**:
   - Write a class `BankAccount` with private attributes `account_number` and `balance`.
   - Implement a method to deposit money and check the balance.
   - Try accessing `account_number` directly from outside the class to see the data protection in action.

2. **Abstraction**:
   - Create a class `Library` that has methods `add_book()`, `remove_book()`, and `display_books()`.
   - Only expose these methods without revealing any details of how the books are stored or managed internally.

3. **Inheritance**:
   - Create a parent class `Employee` with attributes `name` and `salary`.
   - Create a child class `Developer` that inherits `Employee` and has an additional attribute `programming_language`.
   - Write a method in `Developer` to display details of the developer.

4. **Polymorphism**:
   - Create classes `Cat` and `Lion` with a method `speak()`, where `Cat` says "Meow" and `Lion` says "Roar".
   - Demonstrate polymorphism by calling `speak()` on objects of both classes in a loop.

---
